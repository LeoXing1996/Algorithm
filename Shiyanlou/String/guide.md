# 经典算法解体实战——字符串

## 第一题

判断两个字符串是否互为回文

样例：

* 输入：`s="abcd", t="dcab"`

* 输出：`return true`

## 第二题

给出一个偏移量`offset`，之后将字符串向左偏移若干位

样例：

* 输入 & 输出
    ```[language=c]
    given："abcdefg"
    offset=0 => "abcdefg"
    offset=1 => "gabcdef"
    offset=2 => "fgabcde"
    offset=3 => "efgabcd"
    ```

## 第三题

给出两个字符串，求第二个字符串是否为第一个字符串的子串，如果是，则返回首位所在序号/下标(从0开始)，否则返回-1

### 样例

* 输入&输出：
    ```[language=C]
    source="source" target="target" return = -1
    source="abcdabcdefg" target="efg" return = 8
    ```

### 解决方法

方法1：使用二重循环进行判断，外循环指明主串开始比较的位点，内循环指明正在进行比较的模式串位点，即比较`s[i+j]==t[j]`

方法2：KMP 需要构建`next_value`函数，由于序号从0开始，有点不适应

## 第四题

判断两个字符串是否为 __变位词(anagrams)__ ，即两个字符串是否由 __完全相同__ 的字符组成

### 样例

* 输入&输出：
    ```[language=C]
    s="abcd" t="bcda" return=1
    ```

### 解决方法

方法1：将两个字符进行排序，如果排序后完全相等，则可以认为是互为变位词

方法2：建立一个 __含有26个元素的数组__ / __列表__ / __key为26个字母的哈希表__ 之后对主串进行分别遍历，每遇到一个字母，就将相应位置的值加一；再对模式串进行遍历，将相应位置减一。便利完成后若表中至均为0，则二者互为变位词

## 第五题

给出一个字符串数组，判断其中是否有互为变位词的元素，若有，则将元素输出

### 样例

* 输入&输出：
    ```[language=C]
    given = {"lint", "intl", "inlt", "int"}
    res = {"lint", "intl", "inlt"}
    ```

### 解决方法

方法1：使用基于 第四题 方法2 的二重循环解决，对每个两个字符串进行一次基于字母个数的匹配操作，将互为变位词的串的序号加入标志数组`res`，同时建立`visited`数组以及标志变量`flag`防止重复添加，时间复杂度较高

方法2：对每个字符串进行一次排序，之后建立哈希表，表的`key`为每个字符串的排序结果，`value`为排序结果对应的元素个数，即护卫变位词的串的个数，之后筛选表中`value`不为1的`key`，即可得到互为变位词的串

由于C语言没有自带的哈希表操作，因此在排序使用方法1的二重循环进行判断

## 第六题

给出一个由多个单词组成的字符串，其中串首和串尾均可能含有空格，串中空格可能多余一个. 按照单词次序将此串逆序

### 样例

* 输入&输出：
    ```[language=C]
    s="the sky is blue"
    return "blue is sky the"
    ```

### 解决方法

方法(`6.c`中采用的)：首先找到字符串第一个单词的首字母位置(`while`循环判断)，之后从起始位开始通过单词之间的空格判断单词个数，保存为`num`. 之后建立一个字符串指针的指针,用来保存串中的几个单词, 从后向前对串进行访问, 每次访问时: 首先将访问起点(`end`)前移, 找到应当访问的单词的末尾(防止单词间的多余空格); 之后使用循环找到单词的首字母的前一个空格位(`i`); 之后将单词进行保存; 最后将访问起点移动到首字母的前一个空格位. 依次循环`num`次, 即可得到逆序的单词序列

## 第七题

给出一个含有符号的字符串, 判断字符串去除符号后是否位 __回文(Palindrome)__ 字符串.

### 样例

* 输入&输出:
    ```[language=C]
    s1 = "A man, a plan, a canal: Panama" return true
    s2 = "race a car" return false
    ```

### 解决方法

方法: 使用两个编号, 分别记录字符串的比较起点与终点, 如果某个位置遇到空格或符号, 就进行相应的递增或递减操作, 在均指向字符时进行比较. 当二者指示字符不等或 起点位置大于终点位置时,跳出循环. 之后判断跳出循环的原因, 返回结果.

## 第八题

给出一个字符串, 求其最大回文子串

### 样例

* 输入&输出
    ```[language=C]
    string="abcdzdcab" res="cdzdc"
    ```

### 解决方法

方法1(<img src="https://latex.codecogs.com/gif.latex?O(n^2)" title="O(n^2)" />): 从字符串的第二位开始, 判断其左右是否能够成回文, 找到以该位置为中心的最大回文子串. 之后依次遍历震哥哥字符串, 采用相同的方法进行判断, 即可找到最大回文子串.

方法2(O(n)): 待更新

## 第九题

给出一个字符串以及字符串的实际长度, 储存在足够长的数组中. 将字符串中的空格替换成`%20`.

### 样例

* 输入 & 输出
    ```[language=C]
    Given "Mr John Smith", length = 13.
    return "Mr%20John%20Smith".
    ```

### 解决方法

方法1: 从前向后遍历, 找到空格后进行修改. 时间复杂度较高. 见`solution1`

方法2: 联想到插入排序的做法——从后往前遍历, 空格处标记下就好了. 由于不知道新数组的长度, 故首先需要遍历一次原数组, 找出空格个数, 进而求出新的字符串长度. 从而从后向前实现字符串的替换与复制. 见`solution2`

## 第十题

给出两个字符串, 进行模式匹配. 其中`?`代表任意单个字符, `*`代表任意字符串.

### 样例

* 输入&输出
    ```[language=C]
    isMatch("aa","a") → false
    isMatch("aa","aa") → true
    isMatch("aaa","aa") → false
    isMatch("aa", "*") → true
    isMatch("aa", "a*") → true
    isMatch("ab", "?*") → true
    isMatch("aab", "c*a*b") → false
    ```

### 解决方法

当`s`与`t`在比较位置相等或`t`在比较位置等于`'?'`时, 直接将比较位置标记递增; 若`t`中出现`'*'`, 则相当于判断`s`中是否存在一个子串与`t`中剩余位置的字符串相匹配, 于是可以记录`t`剩余部分的起始位点`start_t` 以及`s`寻找子串的起始位点`start_s`, 如果遇到不匹配情况, 则将`start_s`前移一位, 之后将`s`与`t`的比较位点回溯回相应的`start`位置. 最后当`s`位移到结尾时, 检验`t`是否完成了比较, 如果完成了比较, 则说明比配成功.

但是在检验时需要着重注意的是`*`位于结尾且`t`的长度大于`s`的情况. 如: `s="a" t="***"`此时当`s`退出比较时, `t`还指向第二个`*`的位置, 由于`*`可以代表任意字符串, 因此在退出循环后, 需要额外对`t`中的`*`进行处理.