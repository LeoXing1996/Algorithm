# 经典算法解体实战——字符串

## 第一题

判断两个字符串是否互为回文

样例：

* 输入：`s="abcd", t="dcab"`

* 输出：`return true`

## 第二题

给出一个偏移量`offset`，之后将字符串向左偏移若干位

样例：

* 输入 & 输出
    ```[language=c]
    given："abcdefg"
    offset=0 => "abcdefg"
    offset=1 => "gabcdef"
    offset=2 => "fgabcde"
    offset=3 => "efgabcd"
    ```

## 第三题

给出两个字符串，求第二个字符串是否为第一个字符串的子串，如果是，则返回首位所在序号/下标(从0开始)，否则返回-1

### 样例：

* 输入&输出：
    ```[language=C]
    source="source" target="target" return = -1
    source="abcdabcdefg" target="efg" return = 8
    ```

### 解决方法：

方法1：使用二重循环进行判断，外循环指明主串开始比较的位点，内循环指明正在进行比较的模式串位点，即比较`s[i+j]==t[j]`

方法2：KMP 需要构建`next_value`函数，由于序号从0开始，有点不适应

## 第四题

判断两个字符串是否为 __变位词(anagrams)__ ，即两个字符串是否由 __完全相同__ 的字符组成

### 样例：

* 输入&输出：
    ```[language=C]
    s="abcd" t="bcda" return=1
    ```

### 解决方法：

方法1：将两个字符进行排序，如果排序后完全相等，则可以认为是互为变位词

方法2：建立一个 __含有26个元素的数组__ / __列表__ / __key为26个字母的哈希表__ 之后对主串进行分别遍历，每遇到一个字母，就将相应位置的值加一；再对模式串进行遍历，将相应位置减一。便利完成后若表中至均为0，则二者互为变位词

## 第五题

给出一个字符串数组，判断其中是否有互为变位词的元素，若有，则将元素输出

### 样例：

* 输入&输出：
    ```[language=C]
    given = {"lint", "intl", "inlt", "int"}
    res = {"lint", "intl", "inlt"}
    ```

### 解决方法：

方法1：使用基于 第四题 方法2 的二重循环解决，对每个两个字符串进行一次基于字母个数的匹配操作，将互为变位词的串的序号加入标志数组`res`，同时建立`visited`数组以及标志变量`flag`防止重复添加，时间复杂度较高

方法2：对每个字符串进行一次排序，之后建立哈希表，表的`key`为每个字符串的排序结果，`value`为排序结果对应的元素个数，即护卫变位词的串的个数，之后筛选表中`value`不为1的`key`，即可得到互为变位词的串

由于C语言没有自带的哈希表操作，因此在排序使用方法1的二重循环进行判断